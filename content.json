{"meta":{"title":"henvy'Blog","subtitle":null,"description":null,"author":"henvy","url":"http://henvyluk.com"},"pages":[],"posts":[{"title":"内功修炼篇--runtime","slug":"内功修炼篇--runtime","date":"2016-12-20T16:00:00.000Z","updated":"2016-12-22T15:17:47.000Z","comments":true,"path":"2016/12/21/内功修炼篇--runtime/","link":"","permalink":"http://henvyluk.com/2016/12/21/内功修炼篇--runtime/","excerpt":"","text":"前言因为前些日子写了个关于导航栏控制器的Demo地址在这，开篇我想先稍微讲一下这个，我是觉得原生的导航栏在UI如此丰富以及多层VC的情形下，导航条的颜色、按钮、标题、隐藏等定性的修改显得不够圆滑，因此就想采用一种透明的方式，将VC用NC包装一层再push出去，这里就用到了AssociatedObjects，为所推的VC添加了属性。关联对象只是运行时中的一点，本篇文章想就关联对象和运行时的一些其他常见用法姑且谈谈吾之愚见，望抛砖引玉。 正文其实网上关于运行时的东西多如牛毛，但感觉都像在一遍一遍的嚼舌根又不好理解，我就坦诚相见，拒绝抽象。 #import &lt;objc/runtime.h&gt; 运行时其实就是用C编写的我们oc的基石，我们通过运行时所提供的方法等可以跨越oc层直接与C交互，当然对性能也会有所提升。运行时会对一个类进行完全的分解，将类或者对象的每一个部分抽象成一种类型，如果把oc的类比作一个组装机器人，那他就会被运行时拆分为手臂、腿、身体等，我们可以通过运行时直接获取到机器人的手臂一样，这对于操作一个类的属性或者方法是非常方便的。 我们在开发中切实可以用到的一些场景我做了归纳，下面一一讲解： 1、关联对象关联对象相关的函数主要有三个，命名相当友好到一看就知道其实就是get/set方法，我们可以在category中使用它们实现动态向类中添加属性和方法。 objc_setAssociatedObject objc_getAssociatedObject objc_removeAssociatedObjects 看一个添加属性的例子，我们创建一个NSObject的分类CategoryProperty： @interface NSObject (CategoryProperty) @property (nonatomic, strong) NSObject *property; @end @implementation NSObject (CategoryProperty) - (NSObject *)property { return objc_getAssociatedObject(self, @selector(property)); } - (void)setProperty:(NSObject *)value { objc_setAssociatedObject(self, @selector(property), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } @end key值这三个函数的参数key值推荐三种命名方式： 声明 static char kAssociatedObjectKey，使用 &amp;kAssociatedObjectKey 作为 key 值; 声明 static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey ，使用 kAssociatedObjectKey 作为 key 值； 用 selector ，使用 getter 方法的名称作为 key 值。 上面的例子用的是第三种方法，省的命名了也算简单。 关联策略至于关联策略有五种可供选择，有强弱引用和原子非原子的区分，在绝大多数情况下，我们都会使用OBJC_ASSOCIATION_RETAIN_NONATOMIC 的关联策略，这可以保证我们持有关联对象不会被过早的释放。 在看一个添加方法的例子，我们创建一个UIButton的分类block： typedef void (^btnBlock)(); @interface UIButton (block) - (void)handelWithBlock:(btnBlock)block; @end static const char btnKey; @implementation UIButton (block) - (void)handelWithBlock:(btnBlock)block{ if (block){ objc_setAssociatedObject(self, &amp;btnKey, block, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } [self addTarget:self action:@selector(btnAction) forControlEvents:UIControlEventTouchUpInside]; } - (void)btnAction{ btnBlock block = objc_getAssociatedObject(self, &amp;btnKey); block(); } @end 这样我们就为button添加了一个block的方法，在调用button的时候就可以直接用handelWithBlock来回调了。 2、方法交换顾名思义，就是两个方法执行交换，我们建一个UIViewController的分类VCCategory： @implementation UIViewController (VCCategory) + (void)load { //方法交换应该被保证在程序中只会执行一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ SEL systemSel = @selector(viewWillAppear:); SEL henvySel = @selector(hl_viewWillAppear:); Method systemMethod = class_getInstanceMethod([self class], systemSel); Method henvyMethod = class_getInstanceMethod([self class], henvySel); BOOL isAdd = class_addMethod(self, systemSel, method_getImplementation(henvyMethod), method_getTypeEncoding(henvyMethod)); if (isAdd) { //如果成功，说明类中不存在这个方法的实现 //将被交换方法的实现替换到这个并不存在的实现 class_replaceMethod(self, henvySel, method_getImplementation(systemMethod), method_getTypeEncoding(systemMethod)); }else{ //否则，交换两个方法的实现 method_exchangeImplementations(systemMethod, henvyMethod); } }); } - (void)hl_viewWillAppear:(BOOL)animated{ //这里自己调用自己，表面上循环引用其实已经被viewWillAppear替换掉了 [self hl_viewWillAppear:animated]; NSLog(@&quot;henvy&quot;); } @end 这个时候在一个自己定义的viewController中viewWillAppear方法中就可以看到输出henvy。 3、发送消息发送消息即objc_msgSend方法很简单，这里就举个很简单的例子,比如你要调用形如一下的一个方法， //类、方法、参数 [someObject messageName:parameter]; 还可以用objc_msgSend写作为： objc_msgSend（someObject,@selector（messageName),parameter)； 4、字典转模型KVC是把字典中所有值给模型的属性赋值，这个是要求字典中的Key必须要在模型里能找到相应的值，如果找不到就会报错，因此我们可以通过重写KVC中的forUndefinedKey这个方法。当然我们可以通过runtime的方式去实现，把KVC的原理倒过来，通过遍历模型的值，从字典中取值，这里新建一个模型ModelClass： + (instancetype)modelWithDict:(NSDictionary *)dict{ id objc = [[self alloc] init]; // count:成员变量个数 unsigned int count = 0; // 获取成员变量数组 Ivar *ivarList = class_copyIvarList(self, &amp;count); // 遍历所有成员变量 for (int i = 0; i &lt; count; i++) { // 获取成员变量 Ivar ivar = ivarList[i]; // 获取成员变量名字 NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 获取成员变量类型 NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 格式化 ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\\&quot;&quot; withString:@&quot;&quot;]; ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;]; // 获取key NSString *key = [ivarName substringFromIndex:1]; // 去字典中查找对应value id value = dict[key]; // 二级转换:判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType hasPrefix:@&quot;NS&quot;]) { // 获取类 Class modelClass = NSClassFromString(ivarType); value = [modelClass modelWithDict:value]; } // 给模型中属性赋值 if (value) { [objc setValue:value forKey:key]; } } return objc; } 写在最后总体上来说运行时在开发中比较常用的到的场景我就先总结这么多，当然也欢迎大神能够来补充是最好不过，文章中的测试代码我都写在前言的Demo里了，同时也欢迎到我的Github讨论，如果本文有什么不太对的地方，也请一定要给我指正，感激不尽！ 好了写了这么多有点累洗洗睡了，祝大家晚安！另外送上一首歌【李志—墙上的向日葵】","categories":[],"tags":[],"keywords":[]},{"title":"github+hexo提交到百度谷歌搜索引擎","slug":"github-hexo提交到百度谷歌搜索引擎","date":"2016-12-16T16:00:00.000Z","updated":"2016-12-18T04:28:30.000Z","comments":true,"path":"2016/12/17/github-hexo提交到百度谷歌搜索引擎/","link":"","permalink":"http://henvyluk.com/2016/12/17/github-hexo提交到百度谷歌搜索引擎/","excerpt":"","text":"前言前些日子用GitHub Pages+hexo搭建了一个博客网站，后来发现百度谷歌都是无法搜索到我的网站上的内容，这根本不能忍好吗？于是乎小研究了一下，并写了这篇文章记录一下填坑的过程，看到这相信你也有这样的问题，希望这篇文章会对你有些帮助。 确认收录情况在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有. site:henvyluk.com 1、验证网站验证网站的目的说白了就是证明这个网站是你的，这是你使用站长平台更多功能的前提条件，另外没有梯子的童鞋可以看这里shadowsocks当然如果你有自己的或者不需要谷歌搜索可以忽略。下面是两个搜索引擎入口： Google搜索引擎提交入口 百度搜索引擎提交入口 百度站长平台为未使用百度统计的站点提供三种验证方式：文件验证、html标签验证、CNAME验证，应该说文件和CNAME验证较为简单，我这里统一使用CNAME验证。 文件验证：您需要下载验证文件，将文件上传至您的服务器，放置于域名根目录下。 html标签验证：将html标签添加至网站首页html代码的标签与标签之间。 CNAME验证：您需要登录域名提供商或托管服务提供商的网站，添加新的DNS记录。 CNAME验证需要到你的域名商站点添加DNS解析即可，主机和指向百度已经给你了的，我的域名是在godaddy上，分别添加主机和指向如图下：然后点完成验证即可： 谷歌的就更简单了，直接点验证，等待自动验证结束即可。 2、站点地图站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。 首先在hexo根目录分别安装百度谷歌的站点地图文件： npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 在博客目录的_config.yml中添加路径： //自动生成sitemap sitemap: path: sitemap.xml baidusitemap: path: baidusitemap.xml 接下来编译： hexo g 此时会发现在public下面发现生成了sitemap.xml以及baidusitemap.xml文件，可以看一下这两个文件，大致就是你的域名下的几篇文章的链接，如果不是以你的域名（github），github禁止了百度爬虫，提交了百度也是不会访问的，所以需要改为你自己的域名，我这里自动生成的是我自己的，接下来部署： hexo d 部署成功后分别访问： http://henvyluk.com/sitemap.xml http://henvyluk.com/baidusitemap.xml 3、谷歌收录让谷歌收录我们的博客直接向Google站长工具提交sitemap文件即可，登录谷歌账号，选择当前站点，左边一栏抓取-站点地图-添加站点地图即可，相信谷歌的效率，明天你的站点谷歌就搜索得到了。 4、百度收录谷歌的不要太简单，百度就稍微麻烦一点，分为四种方式来提交你的链接， 主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。 自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。 sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。 手动提交：一次性提交链接给百度，可以使用此种方式。比较推荐前三种提交方式，从效率上来说，接下来依次讲解： 主动推送&gt;自动推送&gt;sitemap 主动推送主动推送官网上也有说明，不过需要一定的代码功底，我这里通过第三方写好的一个插件来做说明，首先，在Hexo根目录下，安装插件： npm install hexo-baidu-url-submit --save 然后，同样在根目录下，把以下内容配置到_config.yml文件中: baidu_url_submit: count: 3 ## 比如3，代表提交最新的三个链接 host: www.henvyluk.com ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 其次，记得查看_config.ym文件中url的值， 必须包含是百度站长平台注册的域名（一般有www）， 比如: # URL url: http://www.henvyluk.com root: / permalink: :year/:month/:day/:title/ 接下来添加一个新的deploy 的类型，用减号区分： deploy: - type: git repository: https://github.com/henvyluk/henvyluk.github.io branch: master - type: baidu_url_submitter 执行hexo deploy的时候，新的连接就会被推送了。这里讲一下原理： 新链接的产生， hexo generate 会产生一个文本文件，里面包含最新的链接 新链接的提交， hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎 自动推送如果是next主题，next主题配置文件中的baidu_push设置为true，就可以了。我的并不是next主题，我用的是icarus，这就要想办法塞进以下的全站点js代码： &lt;script&gt; (function(){ var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); })(); &lt;/script&gt; 一般在以下目录加入中加入即可， blog\\themes\\xxxx\\layout\\_partial\\head.ejs 我的是在 blog\\themes\\icarus\\layout\\common\\head.ejs sitemapsitemap很简单直接提交http://henvyluk.com/baidusitemap.xml就可以了 5、写在最后相比较百度还是要比谷歌慢，总体谷歌提交简单的太多了，谷歌第二天就可以搜索到网站内容，百度不太给力，也使得这篇文章托到了现在，大致的提交流程就是这样，再会！","categories":[],"tags":[],"keywords":[]},{"title":"为你的库添加cocoapods支持","slug":"为你的库添加cocoapods支持","date":"2016-12-13T13:57:06.000Z","updated":"2016-12-17T10:33:01.000Z","comments":true,"path":"2016/12/13/为你的库添加cocoapods支持/","link":"","permalink":"http://henvyluk.com/2016/12/13/为你的库添加cocoapods支持/","excerpt":"","text":"为你的库添加cocoapods支持前言本文意在教大家一步一步将自己的pods发布到CocoaPods中，将自己写的组件或库开源出去，让别人轻轻pod install一下即可安装。自己在上传pods过程中也遇到过一些小坑，也在此做了说明。测试文件为一个很简单的DynamicLabel类，旨在上传pods的过程，写的不好的地方望砖下留情。 1、环境cocoapods的安装这里就不再说了，另外要说明的是你首先要把项目push到github，并release一个版本打上tag标签（目的在于让cocoapods能够根据你提供的tag来锁定版本），如果没有push可cd到你的项目根目录如下： //添加 git add -A //commit git commit -m&quot;version description&quot; //push git push origin master //打上标签 git tag&apos;0.0.3&apos; //推送 git push --tags 2、创建podspec文件cd到你的项目根目录如下： //创建podspec文件 pod spec create DynamicLabel 之后会生成一个.podspec文件，我这里用sublime打开，可以看到里面有很多待编辑项，顾名思义，我这里编辑项如下： s.name = &quot;DynamicLabel&quot; s.version = &quot;0.0.3&quot; s.summary = &quot;limited label Scroll display&quot; s.description = &lt;&lt;-DESC limited label Scroll display. DESC s.homepage = &quot;https://github.com/henvyluk/DynamicLabel&quot; s.license = &quot;MIT&quot; s.author = { &quot;henvyluk&quot; =&gt; &quot;henvyluk@163.com&quot; } s.platform = :ios, &quot;7.0&quot; s.source = { :git =&gt; &quot;https://github.com/henvyluk/DynamicLabel.git&quot;, :tag =&gt; &quot;0.0.3&quot; } s.source_files = &quot;Classes&quot;, &quot;DynamicLabel/Classes/**/*.{h,m}&quot; s.exclude_files = &quot;Classes/Exclude&quot; s.framework = &quot;UIKit&quot; s.requires_arc = true 值得注意的是s.source_files需要根据podspec文件的相对位置来写，表示DynamicLabel 下的Classes文件夹下的所有文件下的所有.h/.m文件，s.framework是你的项目所用到的库，我这里只用到了UIKit，如果你的项目中依赖多个库，可以使用： s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot; 当我们开发的库中也可能还依赖第三方库，例如JSONKit，那么可以使用: s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; 另外如果要添加xib文件，在pod中,xib不能当成源文件(即s.source_files),虽然可能会通过检测，但是pod install之后会报错，所以必须要将xib放入资源文件中(即s.resources)，我就遇到过这种情况，只好更新了一个版本， &quot;Unable to run command &apos;StripNIB xxx.nib&apos; - this target might include its own product&quot;. 再一个添加图片资源的话，类似于xib,不需其它操作，我是将xib和图片都放在s.Resource中形如： s.resources = &quot;xxxx/xxx/*.{png,xib}&quot; 这里看一下我的文件目录： 确认完毕后可通过如下做文件校验： pod lib lint 此时如果有红色错误The spec did not pass validation, due to 1 error可通过在上述指令后加–verbose来看出错误出在哪里，根据提示的信息在做修改，这里提醒s.source_files处容易出错，注意文件的位置，以及s.framework不要出错，否则会项目内的代码不识别。 当出现如下的提示时就代表验证通过了，可以进行下一步了： 3、注册Trunk//分别是你的邮箱和描述 pod trunk register henvyluk@163.com --description=&apos;henvy&apos; 之后你的邮箱会收到确认邮件，点击邮件中的链接后验证后： pod trunk me 如图则表示注册成功，可以进行接下来的push了 4、Trunk push执行： pod trunk push 如果push过程中出错，再检查一下podspec文件，我之前因为版本匹配问题出了错。如果看到如下图即代表上传成功，我的pod版本比较新，好像旧的版本跟这有点区别，会给dataURL和日至打印，这个新版本的比较人性化一点，但为啥我觉得很幼稚有木有。 5、验证说是push成功了怎么说也要验证一下吧，来search一下： pod search DynamicLabel 一看握草！！ push出错了？其实不然，cocoapods官网已经有了我们的代码，不信可以搜搜看，See Podspec还可以看到我们的项目在Specs仓库中的具体位置。问题是我们的电脑~/.cocoapods/repos/master/Specs目录并未更新，执行： //更新pod库 pod setup 这一步具体做了什么东西呢？将官方的Specs仓库文件目录下载下来，然后和我们本地的Specs目录进行比对，增加的增加，删除的删除。 第一次会有点慢，之后再setup的话基本上是秒更，最后setup completed,好了现在是最新的了，再来search一下， 要命了，仍然搜不到，我当初就是卡在了这一步，卡的莫名其妙的，因为实在想不通还有什么会影响search，后来在stackoverflow上有提到search_index.json，这是搜索的缓存目录， //清除索引缓存 rm ~/Library/Caches/CocoaPods/search_index.json 之后pod search DynamicLabel，等待重建索引后： 6、写在最后好了至此制作自己的整个开源库的过程就完成了，如果以后要更新版本，同样修改podspec文件重新push就好了，要注意的是如果你之前提交过pod，那么你需要去Claim your Pod认领: 至此结束，也望大神不吝指教，邮件henvyluk@163.com,同时欢迎跳转我的GitHub主页讨论，再会！","categories":[],"tags":[],"keywords":[]},{"title":"iOS IJKPlayer RTMP播放器的集成","slug":"iOS IJKPlayer RTMP播放器的集成","date":"2016-12-05T13:33:06.000Z","updated":"2016-12-17T10:33:41.000Z","comments":true,"path":"2016/12/05/iOS IJKPlayer RTMP播放器的集成/","link":"","permalink":"http://henvyluk.com/2016/12/05/iOS IJKPlayer RTMP播放器的集成/","excerpt":"","text":"iOS IJKPlayer RTMP播放器的集成前言前些日子公司要做视频直播，一直也是项目的原因没来得及整理内容。周末闲暇时间特来写篇文章，对IJKPlayer播放器的集成做一下归纳，希望对要做iOS视频直播方向的童鞋们有所帮助。 1、环境搭建总结来说就是HomeBrew or MacPorts、git、yasm的安装(Homebrew是Mac OSX上的软件包管理工具，当时macOS Sierra刚刚出来我就手贱更新了，导致HomeBrew安装出现了问题，所以采用了MacPorts，官方推荐HomeBrew)。 这里我只做一下版本检查：首先HomeBrew： ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 待HomeBrew安装完毕即git、yasm： brew install git brew install yasm 2.下载ijkplayer编译1、 首先新建要下载的文件夹ijkplayer并cd到该目录下。 2、 紧接着将ijkplayer文件克隆到新建的文件夹内，在终端输入： //git克隆 git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-ios //进入ijkplayer-ios cd ijkplayer-ios //切换分支 git checkout -B latest k0.7.5 如图所示：3、下载ffmpeg并编译 这一步比较纠结国外网络访问的问题，如果失败就多试几次。 //依然在ijkplayer-ios下载ffmpeg ./init-ios.sh //进入ios目录 cd ios 这一步如果前面没有问题，此时的terminal就像打了鸡血一样狂奔…… (注意中途会有n多个警告，但不要出错就没问题) //clean ./compile-ffmpeg.sh clean //编译 ./compile-ffmpeg.sh all 成功走到这一步就离成功不远了，按步骤走是不会出现问题的，即便有大部分也是网络的原因毕竟大天朝对国外的网络都懂的。 3、demo的处理1、打开官方demo并运行 2、只要前面的流程没报错，这里编译运行都不会出现问题：可以在Online Samples中选择一个m3u8测试ijkplayer是否运行正常如图： 4、制作framework1、打开ijkplayer如图：2、选择edit scheme，下图： 3、将build configuration改为Release后点Close，如图： 4、分别在模拟器和真机(Generic iOS Device也可以)上编译： 5、打开framework所在的目录: 6、看名字就知道一个是模拟器一个是真机，此时cd到Products目录： //合并 lipo -create Release-iphoneos/IJKMediaFramework.framework/IJKMediaFramework Release-iphonesimulator/IJKMediaFramework.framework/IJKMediaFramework -output IJKMediaFramework //将合并后的framework拷贝到iphoneos/IJKMediaFramework.framework中 cp IJKMediaFramework Release-iphoneos/IJKMediaFramework.framework/ 7、此时framework就制作好了，将制作好的iphoneos/IJKMediaFramework.framework复制到要集成的项目中Add Files… 8、在所在的项目中添加动态库 9、测试集成，将本段代码复制到ViewController.m中，可直接使用： #import &quot;ViewController.h&quot; #import &lt;IJKMediaFramework/IJKFFMoviePlayerController.h&gt; @interface ViewController () @property(nonatomic,strong)IJKFFMoviePlayerController * player; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; IJKFFOptions *options = [IJKFFOptions optionsByDefault]; //使用默认配置 NSURL * url = [NSURL URLWithString:@&quot;rtmp://live.hkstv.hk.lxdns.com/live/hks&quot;]; self.player = [[IJKFFMoviePlayerController alloc] initWithContentURL:url withOptions:options]; //初始化播放器，播放在线视频或直播(RTMP) self.player.view.autoresizingMask = UIViewAutoresizingFlexibleWidth|UIViewAutoresizingFlexibleHeight; self.player.view.frame = self.view.bounds; self.player.scalingMode = IJKMPMovieScalingModeAspectFit; //缩放模式 self.player.shouldAutoplay = YES; //开启自动播放 self.view.autoresizesSubviews = YES; [self.view addSubview:self.player.view]; } - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.player prepareToPlay]; } -(void)viewDidDisappear:(BOOL)animated { [super viewDidDisappear:animated]; [self.player shutdown]; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } @end OK完美收工： 3、github地址在这https://github.com/henvyluk/IJKMediaPlayer,另附demo一份，望大神不吝赐教再会！","categories":[],"tags":[],"keywords":[]}]}